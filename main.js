/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DeepResearchPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/constants.ts
var DEFAULT_SETTINGS = {
  // Paths
  seedsPath: "01_Inbox/Seeds",
  plansPath: "02_Research/Plans",
  reportsPath: "02_Research/Reports",
  sourcesPath: "02_Research/Sources",
  topicsPath: "02_Research/Topics",
  templatesPath: "00_System/Templates",
  // Omnivore integration
  omnivoreEnabled: false,
  omnivoreAutoSync: false,
  omnivoreSyncInterval: 60,
  // minutes
  // LLM providers
  defaultLLMProvider: "ollama",
  ollamaEndpoint: "http://localhost:11434",
  // Deep Research MCP
  mcpEnabled: false,
  // Gatekeeper settings
  gatekeeperThreshold: 70,
  autoPromoteHighScore: false,
  // Auto-run settings
  autoRunPlans: false,
  autoRunThreshold: 80,
  // Refresh settings
  scheduledRefresh: false,
  refreshInterval: 7
  // days
};
var FRONTMATTER_TYPES = {
  TOPIC: "topic",
  SEED: "seed",
  PLAN: "dr-plan",
  REPORT: "dr-report",
  SOURCE: "source"
};
var DEFAULT_DELIVERABLES = [
  "Executive Brief (800-1200 words)",
  "Concept Map (Mermaid diagram)",
  "Intervention Table",
  "Source Notes with quality ratings"
];
var DEFAULT_SEARCH_STRATEGY = {
  sourceTypes: [
    "peer-reviewed journals",
    "meta-analyses",
    "systematic reviews",
    "clinical handbooks",
    "reputable organizations"
  ],
  qualityFilters: [
    "minimum sample size > 50",
    "effect sizes reported",
    "limitations acknowledged",
    "potential confounds addressed"
  ],
  diversityRequirements: [
    "multiple theoretical frameworks",
    "cross-cultural perspectives",
    "neurodivergent considerations"
  ]
};
var GATEKEEPER_PROMPT = `You are evaluating whether a research seed deserves deep research. Consider:

1. **Novelty**: How original or underexplored is this topic?
2. **Clinical Value**: How useful would this be for therapeutic practice?
3. **Research Readiness**: Is there sufficient literature to research?
4. **Synthesis Potential**: Can this lead to actionable insights?
5. **Personal Relevance**: How well does this align with the researcher's interests?

Score from 0-100 and provide verdict:
- 80-100: deep-research (comprehensive investigation warranted)
- 50-79: light-scan (basic review sufficient)
- 0-49: archive (not worth pursuing now)

Format your response as:
Score: [number]
Verdict: [deep-research/light-scan/archive]
Rationale: [2-3 sentences explaining your scoring]
Top sub-topics: [3-5 specific areas to explore]`;

// src/managers/DataManager.ts
var import_obsidian = require("obsidian");
var DataManager = class {
  constructor(app, settings) {
    this.lastCacheUpdate = 0;
    this.app = app;
    this.settings = settings;
    this.cache = {
      seeds: /* @__PURE__ */ new Map(),
      plans: /* @__PURE__ */ new Map(),
      reports: /* @__PURE__ */ new Map(),
      sources: /* @__PURE__ */ new Map(),
      topics: /* @__PURE__ */ new Map()
    };
    this.setupWatchers();
  }
  setupWatchers() {
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.handleFileChange(file);
      }
    });
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.handleFileChange(file);
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.handleFileDelete(file);
      }
    });
  }
  async handleFileChange(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = this.parseFrontmatter(content);
      if (!(frontmatter == null ? void 0 : frontmatter.type))
        return;
      switch (frontmatter.type) {
        case FRONTMATTER_TYPES.SEED:
          await this.updateSeedCache(file, content, frontmatter);
          break;
        case FRONTMATTER_TYPES.PLAN:
          await this.updatePlanCache(file, content, frontmatter);
          break;
        case FRONTMATTER_TYPES.REPORT:
          break;
        case FRONTMATTER_TYPES.SOURCE:
          break;
        case FRONTMATTER_TYPES.TOPIC:
          await this.updateTopicCache(file, content, frontmatter);
          break;
      }
    } catch (error) {
      console.error("Error handling file change:", error);
    }
  }
  handleFileDelete(file) {
    const fileId = this.getFileId(file);
    this.cache.seeds.delete(fileId);
    this.cache.plans.delete(fileId);
    this.cache.reports.delete(fileId);
    this.cache.sources.delete(fileId);
    this.cache.topics.delete(fileId);
  }
  getFileId(file) {
    return file.path;
  }
  parseFrontmatter(content) {
    const lines = content.split("\n");
    if (lines[0] !== "---")
      return null;
    let endIndex = -1;
    for (let i = 1; i < lines.length; i++) {
      if (lines[i] === "---") {
        endIndex = i;
        break;
      }
    }
    if (endIndex === -1)
      return null;
    const frontmatterText = lines.slice(1, endIndex).join("\n");
    try {
      const lines2 = frontmatterText.split("\n");
      const result = {};
      lines2.forEach((line) => {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          const value = line.substring(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
          if (value.startsWith("[") && value.endsWith("]")) {
            result[key] = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
          } else {
            result[key] = value;
          }
        }
      });
      return result;
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      return null;
    }
  }
  // Seed Management
  async createSeed(data) {
    const seedId = this.generateId();
    const fileName = `${data.title.replace(/[^a-zA-Z0-9]/g, "_")}_${seedId}.md`;
    const filePath = (0, import_obsidian.normalizePath)(`${this.settings.seedsPath}/${fileName}`);
    const frontmatter = {
      type: "seed",
      topic: data.topic,
      status: "captured",
      priority: data.priority,
      created: new Date().toISOString().split("T")[0],
      score: 0,
      verdict: void 0
    };
    const content = this.buildSeedContent(frontmatter, data);
    await this.ensureFolderExists(this.settings.seedsPath);
    const file = await this.app.vault.create(filePath, content);
    const seed = {
      id: seedId,
      frontmatter,
      title: data.title,
      summary: data.summary,
      questions: data.questions,
      filePath: file.path
    };
    this.cache.seeds.set(seedId, seed);
    return seed;
  }
  buildSeedContent(frontmatter, data) {
    const yamlFrontmatter = this.stringifyYaml(frontmatter);
    return `---
${yamlFrontmatter}---

# Seed: ${data.title}

## Spark

${data.summary}

## Initial Questions

${data.questions.map((q) => `- ${q}`).join("\n")}

## Context & Relevance

- Why is this important now?
- How does this connect to my existing knowledge?
- What practical applications might this have?

## Gatekeeper Assessment

### Evaluation Criteria
- [ ] **Novelty**: Is this underexplored or original?
- [ ] **Clinical Value**: Would this benefit therapeutic practice?
- [ ] **Research Readiness**: Is there sufficient literature?
- [ ] **Synthesis Potential**: Can this lead to actionable insights?
- [ ] **Personal Relevance**: Does this align with my interests?

### Results
- **Score**: 
- **Verdict**: 
- **Rationale**: 
- **Top Sub-topics**: 
  - 
  - 
  - 

## Next Steps

- [ ] Run gatekeeper assessment
- [ ] Promote to research plan (if score \u2265 70)
- [ ] Link to relevant topic hub`;
  }
  async getSeed(seedId) {
    if (this.cache.seeds.has(seedId)) {
      return this.cache.seeds.get(seedId);
    }
    await this.refreshSeedsCache();
    return this.cache.seeds.get(seedId);
  }
  async getSeeds(filters) {
    await this.refreshSeedsCache();
    let seeds = Array.from(this.cache.seeds.values());
    if (filters) {
      if (filters.topic) {
        seeds = seeds.filter((seed) => seed.frontmatter.topic === filters.topic);
      }
      if (filters.status) {
        seeds = seeds.filter((seed) => seed.frontmatter.status === filters.status);
      }
      if (filters.score !== void 0) {
        seeds = seeds.filter((seed) => (seed.frontmatter.score || 0) >= filters.score);
      }
      if (filters.dateRange) {
        seeds = seeds.filter((seed) => {
          if (!seed.frontmatter.created)
            return false;
          const seedDate = new Date(seed.frontmatter.created);
          return seedDate >= filters.dateRange[0] && seedDate <= filters.dateRange[1];
        });
      }
    }
    return seeds.sort((a, b) => {
      const dateA = a.frontmatter.created || "";
      const dateB = b.frontmatter.created || "";
      return dateB.localeCompare(dateA);
    });
  }
  async updateSeed(seedId, updates) {
    const seed = await this.getSeed(seedId);
    if (!seed)
      throw new Error(`Seed ${seedId} not found`);
    const file = this.app.vault.getAbstractFileByPath(seed.filePath);
    if (!file)
      throw new Error(`Seed file ${seed.filePath} not found`);
    const content = await this.app.vault.read(file);
    const updatedContent = this.updateFrontmatter(content, updates);
    await this.app.vault.modify(file, updatedContent);
  }
  async updateSeedCache(file, content, frontmatter) {
    var _a;
    const seedId = this.getFileId(file);
    const bodyContent = this.extractBodyContent(content);
    const lines = bodyContent.split("\n");
    const titleMatch = (_a = lines.find((line) => line.startsWith("# Seed:"))) == null ? void 0 : _a.replace("# Seed:", "").trim();
    const summaryStart = lines.findIndex((line) => line.trim() === "## Spark") + 1;
    const summaryEnd = lines.findIndex((line, index) => index > summaryStart && line.startsWith("##"));
    const summary = lines.slice(summaryStart, summaryEnd === -1 ? summaryStart + 5 : summaryEnd).join("\n").trim();
    const questionsStart = lines.findIndex((line) => line.trim() === "## Initial Questions") + 1;
    const questionsEnd = lines.findIndex((line, index) => index > questionsStart && line.startsWith("##"));
    const questions = lines.slice(questionsStart, questionsEnd === -1 ? questionsStart + 10 : questionsEnd).filter((line) => line.trim().startsWith("-")).map((line) => line.replace(/^-\s*/, "").trim()).filter((q) => q.length > 0);
    const seed = {
      id: seedId,
      frontmatter,
      title: titleMatch || "Untitled Seed",
      summary: summary || "",
      questions: questions || [],
      filePath: file.path
    };
    this.cache.seeds.set(seedId, seed);
  }
  // Plan Management
  async createPlan(data) {
    const planId = this.generateId();
    const fileName = `${data.title.replace(/[^a-zA-Z0-9]/g, "_")}_${planId}.md`;
    const filePath = (0, import_obsidian.normalizePath)(`${this.settings.plansPath}/${fileName}`);
    const frontmatter = {
      type: "dr-plan",
      topic: data.topic,
      seed: data.seedId,
      status: "planned",
      created: new Date().toISOString().split("T")[0],
      deliverables: data.deliverables,
      run_id: ""
    };
    const content = this.buildPlanContent(frontmatter, data);
    await this.ensureFolderExists(this.settings.plansPath);
    const file = await this.app.vault.create(filePath, content);
    const plan = {
      id: planId,
      frontmatter,
      title: data.title,
      thesis: data.thesis,
      subQuestions: data.subQuestions,
      searchStrategy: data.searchStrategy,
      deliverables: data.deliverables,
      rubric: data.rubric,
      filePath: file.path
    };
    this.cache.plans.set(planId, plan);
    return plan;
  }
  buildPlanContent(frontmatter, data) {
    var _a, _b;
    const yamlFrontmatter = this.stringifyYaml(frontmatter);
    return `---
${yamlFrontmatter}---

# Deep Research Plan: ${data.title}

## Research Question

**Primary Question**: ${data.subQuestions[0] || ""}

**Refined Thesis**: ${data.thesis}

## Sub-Questions

${data.subQuestions.map((q, i) => `${i + 1}. ${q}`).join("\n")}

## Search Strategy

### Priority Source Types
${((_a = data.searchStrategy.sourceTypes) == null ? void 0 : _a.map((type) => `- ${type}`).join("\n")) || ""}

### Quality Filters
- Minimum sample size > 50 (for quantitative studies)
- Effect sizes reported
- Limitations and potential confounds acknowledged

### Diversity Requirements
${((_b = data.searchStrategy.diversityRequirements) == null ? void 0 : _b.map((req) => `- ${req}`).join("\n")) || ""}

## Deliverables

${data.deliverables.map((deliverable) => `- ${deliverable}`).join("\n")}

## Quality Rubric

${data.rubric}

## Execution Plan

- [ ] Literature search phase
- [ ] Source evaluation and quality assessment
- [ ] Synthesis and analysis
- [ ] Output generation

## Timeline

- **Estimated Duration**: TBD
- **Target Completion**: TBD
- **Review Date**: TBD`;
  }
  async getPlans(filters) {
    await this.refreshPlansCache();
    let plans = Array.from(this.cache.plans.values());
    if (filters) {
      if (filters.topic) {
        plans = plans.filter((plan) => plan.frontmatter.topic === filters.topic);
      }
      if (filters.status) {
        plans = plans.filter((plan) => plan.frontmatter.status === filters.status);
      }
    }
    return plans.sort((a, b) => {
      const dateA = a.frontmatter.created || "";
      const dateB = b.frontmatter.created || "";
      return dateB.localeCompare(dateA);
    });
  }
  async updatePlanCache(file, content, frontmatter) {
    var _a, _b;
    const planId = this.getFileId(file);
    const bodyContent = this.extractBodyContent(content);
    const lines = bodyContent.split("\n");
    const titleMatch = (_a = lines.find((line) => line.startsWith("# Deep Research Plan:"))) == null ? void 0 : _a.replace("# Deep Research Plan:", "").trim();
    const thesisLine = lines.find((line) => line.includes("**Refined Thesis**:"));
    const thesis = ((_b = thesisLine == null ? void 0 : thesisLine.split("**Refined Thesis**:")[1]) == null ? void 0 : _b.trim()) || "";
    const subQuestionStart = lines.findIndex((line) => line.trim() === "## Sub-Questions") + 1;
    const subQuestionEnd = lines.findIndex((line, index) => index > subQuestionStart && line.startsWith("##"));
    const subQuestions = lines.slice(subQuestionStart, subQuestionEnd === -1 ? lines.length : subQuestionEnd).filter((line) => /^\d+\./.test(line.trim())).map((line) => line.replace(/^\d+\.\s*/, "").trim());
    const plan = {
      id: planId,
      frontmatter,
      title: titleMatch || "Untitled Plan",
      thesis,
      subQuestions,
      searchStrategy: {
        sourceTypes: [],
        qualityFilters: []
      },
      deliverables: frontmatter.deliverables || [],
      rubric: "",
      filePath: file.path
    };
    this.cache.plans.set(planId, plan);
  }
  // Topic Management
  async createTopic(data) {
    const topicId = data.slug;
    const fileName = `${data.slug}.md`;
    const filePath = (0, import_obsidian.normalizePath)(`${this.settings.topicsPath}/${fileName}`);
    const frontmatter = {
      type: "topic",
      slug: data.slug,
      title: data.title,
      status: "active",
      created: new Date().toISOString().split("T")[0],
      tags: data.tags || [],
      description: data.description
    };
    const content = this.buildTopicContent(frontmatter, data);
    await this.ensureFolderExists(this.settings.topicsPath);
    const file = await this.app.vault.create(filePath, content);
    const topic = {
      id: topicId,
      frontmatter,
      title: data.title,
      description: data.description,
      seeds: [],
      plans: [],
      reports: [],
      sources: [],
      filePath: file.path
    };
    this.cache.topics.set(topicId, topic);
    return topic;
  }
  buildTopicContent(frontmatter, data) {
    const yamlFrontmatter = this.stringifyYaml(frontmatter);
    return `---
${yamlFrontmatter}---

# Topic Hub: ${data.title}

## Overview

${data.description}

## Research Questions

### Primary Questions
- 

### Secondary Questions
- 

## Active Research

### Current Plans
*Links to active research plans will appear here*

### Recent Reports
*Links to completed research reports will appear here*

## Knowledge Base

### Source Notes
\`\`\`dataview
TABLE title as "Title", authors as "Authors", year as "Year", quality as "Quality"
FROM "02_Research/Sources"
WHERE contains(file.frontmatter.topic, "${data.slug}")
SORT quality DESC, year DESC
\`\`\`

### Key Claims
*Major findings and assertions with source support*

## Research Gaps

### Identified Gaps
- 

### Priority Areas
- 

## Next Steps

- [ ] Review pending seeds
- [ ] Execute planned research
- [ ] Update knowledge base`;
  }
  async getTopics() {
    await this.refreshTopicsCache();
    return Array.from(this.cache.topics.values()).sort((a, b) => a.title.localeCompare(b.title));
  }
  async updateTopicCache(file, content, frontmatter) {
    const topicId = frontmatter.slug;
    const topic = {
      id: topicId,
      frontmatter,
      title: frontmatter.title,
      description: frontmatter.description || "",
      seeds: [],
      plans: [],
      reports: [],
      sources: [],
      filePath: file.path
    };
    this.cache.topics.set(topicId, topic);
  }
  // Cache management
  async refreshCache() {
    await Promise.all([
      this.refreshSeedsCache(),
      this.refreshPlansCache(),
      this.refreshTopicsCache(),
      this.refreshReportsCache(),
      this.refreshSourcesCache()
    ]);
    this.lastCacheUpdate = Date.now();
  }
  async refreshSeedsCache() {
    const seedsFolder = this.app.vault.getAbstractFileByPath(this.settings.seedsPath);
    if (!(seedsFolder instanceof import_obsidian.TFolder))
      return;
    for (const file of seedsFolder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        try {
          const content = await this.app.vault.read(file);
          const frontmatter = this.parseFrontmatter(content);
          if ((frontmatter == null ? void 0 : frontmatter.type) === "seed") {
            await this.updateSeedCache(file, content, frontmatter);
          }
        } catch (error) {
          console.error(`Error processing seed file ${file.path}:`, error);
        }
      }
    }
  }
  async refreshPlansCache() {
    const plansFolder = this.app.vault.getAbstractFileByPath(this.settings.plansPath);
    if (!(plansFolder instanceof import_obsidian.TFolder))
      return;
    for (const file of plansFolder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        try {
          const content = await this.app.vault.read(file);
          const frontmatter = this.parseFrontmatter(content);
          if ((frontmatter == null ? void 0 : frontmatter.type) === "dr-plan") {
            await this.updatePlanCache(file, content, frontmatter);
          }
        } catch (error) {
          console.error(`Error processing plan file ${file.path}:`, error);
        }
      }
    }
  }
  async refreshTopicsCache() {
    const topicsFolder = this.app.vault.getAbstractFileByPath(this.settings.topicsPath);
    if (!(topicsFolder instanceof import_obsidian.TFolder))
      return;
    for (const file of topicsFolder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        try {
          const content = await this.app.vault.read(file);
          const frontmatter = this.parseFrontmatter(content);
          if ((frontmatter == null ? void 0 : frontmatter.type) === "topic") {
            await this.updateTopicCache(file, content, frontmatter);
          }
        } catch (error) {
          console.error(`Error processing topic file ${file.path}:`, error);
        }
      }
    }
  }
  // Stub methods for reports and sources - will be implemented later
  async getReports(filters) {
    return [];
  }
  async getSources(filters) {
    return [];
  }
  async refreshReportsCache() {
  }
  async refreshSourcesCache() {
  }
  // Utility methods
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  stringifyYaml(obj) {
    let result = "";
    for (const [key, value] of Object.entries(obj)) {
      if (Array.isArray(value)) {
        result += `${key}: [${value.map((v) => `"${v}"`).join(", ")}]
`;
      } else if (typeof value === "string") {
        result += `${key}: "${value}"
`;
      } else {
        result += `${key}: ${value}
`;
      }
    }
    return result.trim();
  }
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian.normalizePath)(folderPath);
    const existingFolder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!existingFolder) {
      await this.app.vault.createFolder(normalizedPath);
    }
  }
  extractBodyContent(content) {
    const lines = content.split("\n");
    const frontmatterEnd = lines.indexOf("---", 1);
    if (frontmatterEnd === -1)
      return content;
    return lines.slice(frontmatterEnd + 1).join("\n");
  }
  updateFrontmatter(content, updates) {
    const lines = content.split("\n");
    const frontmatterStart = lines.indexOf("---");
    const frontmatterEnd = lines.indexOf("---", 1);
    if (frontmatterStart === -1 || frontmatterEnd === -1) {
      return content;
    }
    const frontmatterText = lines.slice(frontmatterStart + 1, frontmatterEnd).join("\n");
    let frontmatter;
    try {
      const lines2 = frontmatterText.split("\n");
      frontmatter = {};
      lines2.forEach((line) => {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          const value = line.substring(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
          if (value.startsWith("[") && value.endsWith("]")) {
            frontmatter[key] = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
          } else {
            frontmatter[key] = value;
          }
        }
      });
    } catch (error) {
      console.error("Error parsing frontmatter for update:", error);
      return content;
    }
    Object.assign(frontmatter, updates);
    const newFrontmatterText = this.stringifyYaml(frontmatter);
    const newLines = [
      "---",
      ...newFrontmatterText.split("\n"),
      "---",
      ...lines.slice(frontmatterEnd + 1)
    ];
    return newLines.join("\n");
  }
};

// src/managers/CommandManager.ts
var import_obsidian4 = require("obsidian");

// src/ui/modals/SeedModal.ts
var import_obsidian2 = require("obsidian");
var SeedModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.topics = [];
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.result = {
      title: "",
      summary: "",
      topic: "",
      priority: "medium",
      questions: [""]
    };
  }
  async onOpen() {
    this.topics = await this.plugin.dataManager.getTopics();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create New Research Seed" });
    new import_obsidian2.Setting(contentEl).setName("Title").setDesc("Brief, descriptive title for this research idea").addText((text) => {
      text.setPlaceholder('e.g., "Role of self-trust in therapeutic outcomes"').setValue(this.result.title).onChange(async (value) => {
        this.result.title = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Topic").setDesc("Select an existing topic or create a new one").addDropdown((dropdown) => {
      dropdown.addOption("", "Select a topic...");
      this.topics.forEach((topic) => {
        dropdown.addOption(topic.frontmatter.slug, topic.title);
      });
      dropdown.addOption("__new__", "+ Create New Topic");
      dropdown.setValue(this.result.topic).onChange(async (value) => {
        if (value === "__new__") {
          this.showNewTopicInput();
        } else {
          this.result.topic = value;
        }
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Priority").setDesc("How important is this research idea?").addDropdown((dropdown) => {
      dropdown.addOptions({
        "low": "Low",
        "medium": "Medium",
        "high": "High"
      });
      dropdown.setValue(this.result.priority).onChange(async (value) => {
        this.result.priority = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Summary").setDesc("Describe what sparked this research idea").addTextArea((text) => {
      text.setPlaceholder("Explain the key insight, observation, or question that led to this research idea...").setValue(this.result.summary).onChange(async (value) => {
        this.result.summary = value;
      });
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    const questionsContainer = contentEl.createDiv("questions-container");
    this.renderQuestions(questionsContainer);
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.cssText = "display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const submitButton = buttonContainer.createEl("button", {
      text: "Create Seed",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.handleSubmit());
  }
  renderQuestions(container) {
    container.empty();
    const heading = container.createEl("h3", { text: "Initial Questions" });
    const desc = container.createEl("p", {
      text: "What specific questions do you want to explore?",
      cls: "setting-item-description"
    });
    this.result.questions.forEach((question, index) => {
      const questionDiv = container.createDiv("question-item");
      questionDiv.style.cssText = "display: flex; gap: 10px; align-items: center; margin-bottom: 10px;";
      const input = questionDiv.createEl("input", {
        type: "text",
        placeholder: "Enter a research question...",
        value: question
      });
      input.style.cssText = "flex: 1;";
      input.addEventListener("input", (e) => {
        this.result.questions[index] = e.target.value;
      });
      const removeBtn = questionDiv.createEl("button", {
        text: "\xD7",
        cls: "question-remove-btn"
      });
      removeBtn.style.cssText = "width: 24px; height: 24px; border-radius: 50%; border: none; background: var(--background-modifier-error); color: white; cursor: pointer;";
      removeBtn.addEventListener("click", () => {
        this.result.questions.splice(index, 1);
        if (this.result.questions.length === 0) {
          this.result.questions.push("");
        }
        this.renderQuestions(container);
      });
      if (this.result.questions.length === 1) {
        removeBtn.style.visibility = "hidden";
      }
    });
    const addButton = container.createEl("button", {
      text: "+ Add Question",
      cls: "add-question-btn"
    });
    addButton.style.cssText = "margin-top: 10px;";
    addButton.addEventListener("click", () => {
      this.result.questions.push("");
      this.renderQuestions(container);
    });
  }
  showNewTopicInput() {
    const modal = new import_obsidian2.Modal(this.app);
    const { contentEl } = modal;
    contentEl.createEl("h3", { text: "Create New Topic" });
    let newTopicTitle = "";
    let newTopicSlug = "";
    let newTopicDescription = "";
    new import_obsidian2.Setting(contentEl).setName("Topic Title").addText((text) => {
      text.setPlaceholder('e.g., "Confidence & Self-Trust"').onChange((value) => {
        newTopicTitle = value;
        newTopicSlug = value.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "_");
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Description").addTextArea((text) => {
      text.setPlaceholder("Brief description of this research topic...").onChange((value) => {
        newTopicDescription = value;
      });
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.cssText = "display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const createBtn = buttonContainer.createEl("button", {
      text: "Create Topic",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", async () => {
      if (newTopicTitle) {
        await this.plugin.commandManager.createTopicHub({
          title: newTopicTitle,
          slug: newTopicSlug,
          description: newTopicDescription
        });
        this.result.topic = newTopicSlug;
        modal.close();
        this.onOpen();
      }
    });
    modal.open();
  }
  async handleSubmit() {
    if (!this.result.title) {
      new import_obsidian2.Notice("Please enter a title for the seed");
      return;
    }
    if (!this.result.summary) {
      new import_obsidian2.Notice("Please enter a summary for the seed");
      return;
    }
    this.result.questions = this.result.questions.filter((q) => q.trim() !== "");
    try {
      await this.onSubmit(this.result);
      this.close();
      new import_obsidian2.Notice("Research seed created successfully!");
    } catch (error) {
      console.error("Error creating seed:", error);
      new import_obsidian2.Notice("Failed to create seed. Please try again.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/modals/PlanModal.ts
var import_obsidian3 = require("obsidian");
var PlanModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, onSubmit, seedId) {
    super(app);
    this.topics = [];
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.seedId = seedId;
    this.result = {
      title: "",
      topic: "",
      thesis: "",
      subQuestions: [""],
      deliverables: [...DEFAULT_DELIVERABLES],
      searchStrategy: { ...DEFAULT_SEARCH_STRATEGY },
      rubric: "Minimum 15 sources, 10 peer-reviewed. Every claim must link to source. Quality ratings required."
    };
  }
  async onOpen() {
    this.topics = await this.plugin.dataManager.getTopics();
    if (this.seedId) {
      this.seed = await this.plugin.dataManager.getSeed(this.seedId);
      if (this.seed) {
        this.result.title = `Research Plan: ${this.seed.title}`;
        this.result.topic = this.seed.frontmatter.topic || "";
      }
    }
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create Research Plan" });
    if (this.seed) {
      const seedInfo = contentEl.createDiv("seed-info");
      seedInfo.innerHTML = `
				<div class="callout" style="margin-bottom: 20px;">
					<div class="callout-title">Based on Seed</div>
					<div class="callout-content">
						<strong>${this.seed.title}</strong><br>
						<em>${this.seed.summary}</em>
					</div>
				</div>
			`;
    }
    this.renderBasicInfo(contentEl);
    this.renderResearchDesign(contentEl);
    this.renderDeliverables(contentEl);
    this.renderSearchStrategy(contentEl);
    this.renderQualityRubric(contentEl);
    this.renderButtons(contentEl);
  }
  renderBasicInfo(container) {
    const section = container.createDiv("plan-section");
    section.createEl("h3", { text: "Basic Information" });
    new import_obsidian3.Setting(section).setName("Plan Title").setDesc("Descriptive title for this research plan").addText((text) => {
      text.setPlaceholder('e.g., "Deep Research: Self-Trust and Therapeutic Outcomes"').setValue(this.result.title).onChange((value) => {
        this.result.title = value;
      });
    });
    new import_obsidian3.Setting(section).setName("Topic").setDesc("Select the research topic this plan belongs to").addDropdown((dropdown) => {
      dropdown.addOption("", "Select a topic...");
      this.topics.forEach((topic) => {
        dropdown.addOption(topic.frontmatter.slug, topic.title);
      });
      dropdown.setValue(this.result.topic).onChange((value) => {
        this.result.topic = value;
      });
    });
  }
  renderResearchDesign(container) {
    const section = container.createDiv("plan-section");
    section.createEl("h3", { text: "Research Design" });
    new import_obsidian3.Setting(section).setName("Research Thesis").setDesc("A clear, testable proposition (1-2 sentences)").addTextArea((text) => {
      text.setPlaceholder('e.g., "Self-trust acts as a mediator between therapeutic alliance and positive outcomes, with stronger effects in anxiety and depression treatments."').setValue(this.result.thesis).onChange((value) => {
        this.result.thesis = value;
      });
      text.inputEl.rows = 3;
    });
    const questionsContainer = section.createDiv("sub-questions");
    this.renderSubQuestions(questionsContainer);
    const aiButton = section.createEl("button", {
      text: "\u2728 Generate Sub-Questions",
      cls: "ai-assist-btn"
    });
    aiButton.style.cssText = "margin-top: 10px;";
    aiButton.addEventListener("click", () => this.generateSubQuestions());
  }
  renderSubQuestions(container) {
    container.empty();
    container.createEl("h4", { text: "Sub-Questions" });
    container.createEl("p", {
      text: "Specific questions that will guide the research",
      cls: "setting-item-description"
    });
    const categorizedQuestions = [
      { category: "Definitions & Distinctions", questions: [] },
      { category: "Causal Mechanisms", questions: [] },
      { category: "Measurement & Assessment", questions: [] },
      { category: "Intervention Strategies", questions: [] },
      { category: "Individual Differences", questions: [] },
      { category: "Contradictory Evidence", questions: [] }
    ];
    this.result.subQuestions.forEach((question, index) => {
      const categoryIndex = Math.floor(index / Math.ceil(this.result.subQuestions.length / 6));
      if (categorizedQuestions[categoryIndex]) {
        categorizedQuestions[categoryIndex].questions.push(question);
      }
    });
    categorizedQuestions.forEach((category, categoryIndex) => {
      const categoryDiv = container.createDiv("question-category");
      categoryDiv.createEl("h5", { text: category.category });
      if (category.questions.length === 0) {
        category.questions.push("");
      }
      category.questions.forEach((question, questionIndex) => {
        const questionDiv = categoryDiv.createDiv("question-item");
        questionDiv.style.cssText = "display: flex; gap: 10px; align-items: center; margin-bottom: 8px;";
        const input = questionDiv.createEl("input", {
          type: "text",
          placeholder: `Enter ${category.category.toLowerCase()} question...`,
          value: question
        });
        input.style.cssText = "flex: 1;";
        const globalIndex = this.getGlobalQuestionIndex(categoryIndex, questionIndex);
        input.addEventListener("input", (e) => {
          this.updateSubQuestion(globalIndex, e.target.value);
        });
        const addBtn = questionDiv.createEl("button", {
          text: "+",
          cls: "question-add-btn"
        });
        addBtn.addEventListener("click", () => {
          category.questions.push("");
          this.rebuildSubQuestions();
          this.renderSubQuestions(container);
        });
        const removeBtn = questionDiv.createEl("button", {
          text: "\xD7",
          cls: "question-remove-btn"
        });
        removeBtn.addEventListener("click", () => {
          if (category.questions.length > 1) {
            category.questions.splice(questionIndex, 1);
            this.rebuildSubQuestions();
            this.renderSubQuestions(container);
          }
        });
      });
    });
  }
  getGlobalQuestionIndex(categoryIndex, questionIndex) {
    let globalIndex = 0;
    for (let i = 0; i < categoryIndex; i++) {
      const categoryQuestions = Math.ceil(this.result.subQuestions.length / 6);
      globalIndex += categoryQuestions;
    }
    return globalIndex + questionIndex;
  }
  updateSubQuestion(index, value) {
    if (index < this.result.subQuestions.length) {
      this.result.subQuestions[index] = value;
    }
  }
  rebuildSubQuestions() {
  }
  renderDeliverables(container) {
    const section = container.createDiv("plan-section");
    section.createEl("h3", { text: "Deliverables" });
    section.createEl("p", {
      text: "What outputs should this research produce?",
      cls: "setting-item-description"
    });
    const deliverablesDiv = section.createDiv("deliverables-list");
    DEFAULT_DELIVERABLES.forEach((deliverable, index) => {
      const item = deliverablesDiv.createDiv("deliverable-item");
      item.style.cssText = "display: flex; align-items: center; margin-bottom: 8px;";
      const checkbox = item.createEl("input");
      checkbox.type = "checkbox";
      checkbox.checked = this.result.deliverables.includes(deliverable);
      checkbox.style.cssText = "margin-right: 10px;";
      const label = item.createEl("label", { text: deliverable });
      checkbox.addEventListener("change", (e) => {
        if (e.target.checked) {
          if (!this.result.deliverables.includes(deliverable)) {
            this.result.deliverables.push(deliverable);
          }
        } else {
          const index2 = this.result.deliverables.indexOf(deliverable);
          if (index2 > -1) {
            this.result.deliverables.splice(index2, 1);
          }
        }
      });
    });
  }
  renderSearchStrategy(container) {
    const section = container.createDiv("plan-section");
    section.createEl("h3", { text: "Search Strategy" });
    const sourceTypesDiv = section.createDiv("source-types");
    sourceTypesDiv.createEl("h4", { text: "Priority Source Types" });
    DEFAULT_SEARCH_STRATEGY.sourceTypes.forEach((sourceType) => {
      var _a, _b;
      const item = sourceTypesDiv.createDiv("source-type-item");
      item.style.cssText = "display: flex; align-items: center; margin-bottom: 8px;";
      const checkbox = item.createEl("input");
      checkbox.type = "checkbox";
      checkbox.checked = (_b = (_a = this.result.searchStrategy.sourceTypes) == null ? void 0 : _a.includes(sourceType)) != null ? _b : true;
      checkbox.style.cssText = "margin-right: 10px;";
      const label = item.createEl("label", { text: sourceType });
      checkbox.addEventListener("change", (e) => {
        if (!this.result.searchStrategy.sourceTypes) {
          this.result.searchStrategy.sourceTypes = [];
        }
        if (e.target.checked) {
          if (!this.result.searchStrategy.sourceTypes.includes(sourceType)) {
            this.result.searchStrategy.sourceTypes.push(sourceType);
          }
        } else {
          const index = this.result.searchStrategy.sourceTypes.indexOf(sourceType);
          if (index > -1) {
            this.result.searchStrategy.sourceTypes.splice(index, 1);
          }
        }
      });
    });
    new import_obsidian3.Setting(section).setName("Minimum Sources").setDesc("Minimum number of sources to find").addText((text) => {
      var _a;
      text.setPlaceholder("15").setValue(((_a = this.result.searchStrategy.minSources) == null ? void 0 : _a.toString()) || "15").onChange((value) => {
        this.result.searchStrategy.minSources = parseInt(value) || 15;
      });
    });
    new import_obsidian3.Setting(section).setName("Recency Window").setDesc('How recent should sources be? (e.g., "last 10 years")').addText((text) => {
      text.setPlaceholder("last 10 years").setValue(this.result.searchStrategy.recencyWindow || "last 10 years").onChange((value) => {
        this.result.searchStrategy.recencyWindow = value;
      });
    });
  }
  renderQualityRubric(container) {
    const section = container.createDiv("plan-section");
    section.createEl("h3", { text: "Quality Rubric" });
    new import_obsidian3.Setting(section).setName("Evidence Standards").setDesc("Define minimum quality standards for this research").addTextArea((text) => {
      text.setValue(this.result.rubric).onChange((value) => {
        this.result.rubric = value;
      });
      text.inputEl.rows = 6;
    });
  }
  renderButtons(container) {
    const buttonContainer = container.createDiv("modal-button-container");
    buttonContainer.style.cssText = "display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const submitButton = buttonContainer.createEl("button", {
      text: "Create Plan",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.handleSubmit());
  }
  async generateSubQuestions() {
    var _a;
    if (!this.result.thesis) {
      new import_obsidian3.Notice("Please enter a research thesis first");
      return;
    }
    try {
      const generatedQuestions = await this.plugin.llmService.generateSubQuestions(
        this.result.thesis,
        ((_a = this.seed) == null ? void 0 : _a.summary) || "",
        this.result.topic
      );
      this.result.subQuestions = generatedQuestions;
      const questionsContainer = this.contentEl.querySelector(".sub-questions");
      if (questionsContainer) {
        this.renderSubQuestions(questionsContainer);
      }
      new import_obsidian3.Notice("Sub-questions generated successfully!");
    } catch (error) {
      console.error("Error generating sub-questions:", error);
      new import_obsidian3.Notice("Failed to generate sub-questions. Please try again.");
    }
  }
  async handleSubmit() {
    if (!this.result.title) {
      new import_obsidian3.Notice("Please enter a title for the plan");
      return;
    }
    if (!this.result.topic) {
      new import_obsidian3.Notice("Please select a topic");
      return;
    }
    if (!this.result.thesis) {
      new import_obsidian3.Notice("Please enter a research thesis");
      return;
    }
    this.result.subQuestions = this.result.subQuestions.filter((q) => q.trim() !== "");
    if (this.result.subQuestions.length === 0) {
      new import_obsidian3.Notice("Please add at least one sub-question");
      return;
    }
    try {
      await this.onSubmit({
        ...this.result,
        seedId: this.seedId
      });
      this.close();
      new import_obsidian3.Notice("Research plan created successfully!");
    } catch (error) {
      console.error("Error creating plan:", error);
      new import_obsidian3.Notice("Failed to create plan. Please try again.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/managers/CommandManager.ts
var CommandManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "create-seed",
      name: "Create New Research Seed",
      callback: () => this.createSeed()
    });
    this.plugin.addCommand({
      id: "score-seed",
      name: "Score Current Seed",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && this.isSeedFile(activeFile)) {
          if (!checking) {
            this.scoreSeedFromFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.plugin.addCommand({
      id: "promote-seed",
      name: "Promote Seed to Research Plan",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && this.isSeedFile(activeFile)) {
          if (!checking) {
            this.promoteSeedFromFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.plugin.addCommand({
      id: "create-plan",
      name: "Create Research Plan",
      callback: () => this.createPlan()
    });
    this.plugin.addCommand({
      id: "run-plan",
      name: "Run Research Plan",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && this.isPlanFile(activeFile)) {
          if (!checking) {
            this.runPlanFromFile(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.plugin.addCommand({
      id: "create-topic-hub",
      name: "Create Topic Hub",
      callback: () => this.createTopicHub()
    });
    this.plugin.addCommand({
      id: "open-research-console",
      name: "Open Research Console",
      callback: () => this.openResearchConsole()
    });
    this.plugin.addCommand({
      id: "refresh-data",
      name: "Refresh Research Data",
      callback: () => this.refreshData()
    });
  }
  // Seed Management
  async createSeed() {
    const modal = new SeedModal(this.app, this.plugin, async (data) => {
      try {
        const seed = await this.plugin.dataManager.createSeed(data);
        new import_obsidian4.Notice(`Research seed "${seed.title}" created successfully!`);
        const file = this.app.vault.getAbstractFileByPath(seed.filePath);
        if (file instanceof import_obsidian4.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
      } catch (error) {
        console.error("Error creating seed:", error);
        new import_obsidian4.Notice("Failed to create research seed. Please try again.");
      }
    });
    modal.open();
  }
  async scoreSeed(seedId) {
    try {
      const seed = await this.plugin.dataManager.getSeed(seedId);
      if (!seed) {
        new import_obsidian4.Notice("Seed not found");
        return;
      }
      const loadingNotice = new import_obsidian4.Notice("Scoring seed...", 0);
      const assessment = await this.plugin.gatekeeperService.scoreSeed(seed);
      await this.plugin.dataManager.updateSeed(seedId, {
        score: assessment.score,
        verdict: assessment.verdict,
        modified: new Date().toISOString().split("T")[0]
      });
      await this.updateSeedFileWithAssessment(seed.filePath, assessment);
      loadingNotice.hide();
      new import_obsidian4.Notice(`Seed scored: ${assessment.score}/100 (${assessment.verdict})`);
      if (this.plugin.settings.autoPromoteHighScore && assessment.score >= this.plugin.settings.gatekeeperThreshold) {
        const shouldPromote = await this.confirmAutoPromotion(assessment.score);
        if (shouldPromote) {
          await this.promoteSeedToPlan(seedId);
        }
      }
    } catch (error) {
      console.error("Error scoring seed:", error);
      new import_obsidian4.Notice("Failed to score seed. Please check your LLM configuration.");
    }
  }
  async scoreSeedFromFile(file) {
    const seedId = file.path;
    await this.scoreSeed(seedId);
  }
  async updateSeedFileWithAssessment(filePath, assessment) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian4.TFile))
      return;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let gatekeeperStart = lines.findIndex((line) => line.includes("## Gatekeeper Assessment"));
    if (gatekeeperStart === -1)
      return;
    let resultsStart = lines.findIndex(
      (line, index) => index > gatekeeperStart && line.includes("### Results")
    );
    if (resultsStart === -1) {
      resultsStart = gatekeeperStart + 1;
      lines.splice(resultsStart, 0, "", "### Results");
    }
    const resultsEnd = lines.findIndex(
      (line, index) => index > resultsStart && line.startsWith("##")
    );
    const newResults = [
      `- **Score**: ${assessment.score}/100`,
      `- **Verdict**: ${assessment.verdict}`,
      `- **Rationale**: ${assessment.rationale}`,
      `- **Top Sub-topics**: `,
      ...assessment.topSubTopics.map((topic) => `  - ${topic}`),
      ""
    ];
    const endIndex = resultsEnd === -1 ? lines.length : resultsEnd;
    lines.splice(resultsStart + 1, endIndex - resultsStart - 1, ...newResults);
    await this.app.vault.modify(file, lines.join("\n"));
  }
  async confirmAutoPromotion(score) {
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.app);
      const { contentEl } = modal;
      contentEl.createEl("h3", { text: "Auto-promote Seed?" });
      contentEl.createEl("p", {
        text: `This seed scored ${score}/100, which exceeds the auto-promotion threshold. Would you like to create a research plan?`
      });
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.cssText = "display: flex; gap: 10px; justify-content: center; margin-top: 20px;";
      const noBtn = buttonContainer.createEl("button", { text: "No, Later" });
      noBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const yesBtn = buttonContainer.createEl("button", {
        text: "Yes, Create Plan",
        cls: "mod-cta"
      });
      yesBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  async promoteSeedToPlan(seedId) {
    try {
      const seed = await this.plugin.dataManager.getSeed(seedId);
      if (!seed) {
        new import_obsidian4.Notice("Seed not found");
        return;
      }
      const modal = new PlanModal(this.app, this.plugin, async (planData) => {
        try {
          const plan = await this.plugin.dataManager.createPlan({
            ...planData,
            seedId
          });
          await this.plugin.dataManager.updateSeed(seedId, {
            status: "promoted",
            modified: new Date().toISOString().split("T")[0]
          });
          new import_obsidian4.Notice(`Research plan "${plan.title}" created from seed!`);
          const file = this.app.vault.getAbstractFileByPath(plan.filePath);
          if (file instanceof import_obsidian4.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
          }
        } catch (error) {
          console.error("Error creating plan:", error);
          new import_obsidian4.Notice("Failed to create research plan. Please try again.");
        }
      }, seedId);
      modal.open();
    } catch (error) {
      console.error("Error promoting seed:", error);
      new import_obsidian4.Notice("Failed to promote seed to plan.");
    }
  }
  async promoteSeedFromFile(file) {
    const seedId = file.path;
    await this.promoteSeedToPlan(seedId);
  }
  // Plan Management
  async createPlan(seedId) {
    const modal = new PlanModal(this.app, this.plugin, async (data) => {
      try {
        const plan = await this.plugin.dataManager.createPlan(data);
        new import_obsidian4.Notice(`Research plan "${plan.title}" created successfully!`);
        const file = this.app.vault.getAbstractFileByPath(plan.filePath);
        if (file instanceof import_obsidian4.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
      } catch (error) {
        console.error("Error creating plan:", error);
        new import_obsidian4.Notice("Failed to create research plan. Please try again.");
      }
    }, seedId);
    modal.open();
  }
  async runPlan(planId) {
    try {
      new import_obsidian4.Notice("Starting research job...", 2e3);
      new import_obsidian4.Notice("Research execution not yet implemented. Coming soon!");
    } catch (error) {
      console.error("Error running plan:", error);
      new import_obsidian4.Notice("Failed to run research plan.");
    }
  }
  async runPlanFromFile(file) {
    const planId = file.path;
    await this.runPlan(planId);
  }
  // Topic Management
  async createTopicHub(data) {
    if (data) {
      try {
        const topic = await this.plugin.dataManager.createTopic(data);
        new import_obsidian4.Notice(`Topic hub "${topic.title}" created successfully!`);
      } catch (error) {
        console.error("Error creating topic hub:", error);
        new import_obsidian4.Notice("Failed to create topic hub. Please try again.");
      }
      return;
    }
    const modal = new import_obsidian4.Modal(this.app);
    const { contentEl } = modal;
    contentEl.createEl("h2", { text: "Create Topic Hub" });
    let topicData = {
      title: "",
      slug: "",
      description: "",
      tags: []
    };
    new import_obsidian4.Setting(contentEl).setName("Topic Title").addText((text) => {
      text.setPlaceholder('e.g., "Confidence & Self-Trust"').onChange((value) => {
        topicData.title = value;
        topicData.slug = value.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "_");
      });
    });
    new import_obsidian4.Setting(contentEl).setName("Description").addTextArea((text) => {
      text.setPlaceholder("Brief description of this research topic...").onChange((value) => {
        topicData.description = value;
      });
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.cssText = "display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const createBtn = buttonContainer.createEl("button", {
      text: "Create Topic Hub",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", async () => {
      if (topicData.title && topicData.description) {
        try {
          const topic = await this.plugin.dataManager.createTopic(topicData);
          new import_obsidian4.Notice(`Topic hub "${topic.title}" created successfully!`);
          modal.close();
          const file = this.app.vault.getAbstractFileByPath(topic.filePath);
          if (file instanceof import_obsidian4.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
          }
        } catch (error) {
          console.error("Error creating topic hub:", error);
          new import_obsidian4.Notice("Failed to create topic hub. Please try again.");
        }
      } else {
        new import_obsidian4.Notice("Please fill in all required fields");
      }
    });
    modal.open();
  }
  // UI Commands
  async openResearchConsole() {
    this.plugin.activateView();
  }
  // Utility Commands
  async refreshData() {
    const notice = new import_obsidian4.Notice("Refreshing research data...", 0);
    try {
      await this.plugin.dataManager.refreshCache();
      notice.hide();
      new import_obsidian4.Notice("Research data refreshed successfully!");
    } catch (error) {
      notice.hide();
      console.error("Error refreshing data:", error);
      new import_obsidian4.Notice("Failed to refresh data. Please try again.");
    }
  }
  // Helper methods
  isSeedFile(file) {
    return file.path.startsWith(this.plugin.settings.seedsPath) || file.basename.toLowerCase().includes("seed");
  }
  isPlanFile(file) {
    return file.path.startsWith(this.plugin.settings.plansPath) || file.basename.toLowerCase().includes("plan");
  }
};

// src/templates/TemplateManager.ts
var import_obsidian5 = require("obsidian");
var TemplateManager = class {
  constructor(app, settings) {
    this.templateCache = /* @__PURE__ */ new Map();
    this.app = app;
    this.settings = settings;
  }
  async loadTemplate(templateName) {
    if (this.templateCache.has(templateName)) {
      return this.templateCache.get(templateName);
    }
    const templatePath = (0, import_obsidian5.normalizePath)(`${this.settings.templatesPath}/${templateName}`);
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    if (templateFile instanceof import_obsidian5.TFile) {
      const content = await this.app.vault.read(templateFile);
      this.templateCache.set(templateName, content);
      return content;
    }
    const builtInTemplate = this.getBuiltInTemplate(templateName);
    if (builtInTemplate) {
      this.templateCache.set(templateName, builtInTemplate);
      return builtInTemplate;
    }
    throw new Error(`Template ${templateName} not found`);
  }
  async renderTemplate(templateName, variables) {
    const template = await this.loadTemplate(templateName);
    return this.substituteVariables(template, variables);
  }
  substituteVariables(template, variables) {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      const pattern = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      result = result.replace(pattern, String(value));
    }
    const now = new Date();
    const defaultVars = {
      date: now.toISOString().split("T")[0],
      datetime: now.toISOString(),
      timestamp: now.getTime().toString()
    };
    for (const [key, value] of Object.entries(defaultVars)) {
      const pattern = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      result = result.replace(pattern, value);
    }
    return result;
  }
  getBuiltInTemplate(templateName) {
    const templates = {
      "DR_Seed.md": `---
type: seed
topic: "{{topic}}"
status: captured
priority: medium
created: "{{date}}"
score: 0
verdict: ""
---

# Seed: {{title}}

## Spark

{{summary}}

## Initial Questions

- 

## Gatekeeper Assessment

- **Score**: 
- **Verdict**: 
- **Rationale**: 
- **Top Sub-topics**: 
  - 
`,
      "DR_Plan.md": `---
type: dr-plan
topic: "{{topic}}"
seed: "{{seed_note}}"
status: planned
created: "{{date}}"
deliverables: ["brief", "map", "table"]
---

# Deep Research Plan: {{title}}

## Research Question

**Primary Question**: {{research_question}}

**Refined Thesis**: {{thesis}}

## Sub-Questions

{{sub_questions}}

## Search Strategy

{{search_strategy}}

## Deliverables

- Executive Brief (800-1200 words)
- Concept Map (Mermaid diagram)  
- Intervention Table
- Source Notes with quality ratings

## Quality Rubric

- Minimum 15 sources, 10 peer-reviewed
- Every claim must link to source
- Quality ratings: Strong/Mixed/Weak
- Quote length \u2264 25 words
`,
      "DR_Report.md": `---
type: dr-report
topic: "{{topic}}"
plan: "{{plan_note}}"
run_id: "{{run_id}}"
status: complete
created: "{{date}}"
sources: []
---

# Deep Research Report: {{title}}

## Executive Brief

{{brief}}

## Key Claims

{{claims}}

## Concept Map

\`\`\`mermaid
{{concept_map}}
\`\`\`

## Intervention Table

{{intervention_table}}

## Sources

{{sources}}
`,
      "DR_SourceNote.md": `---
type: source
id: "{{source_id}}"
title: "{{title}}"
authors: [{{authors}}]
year: {{year}}
quality: "{{quality}}"
created: "{{date}}"
---

# {{title}}

## TL;DR

- **One Sentence**: {{one_sentence}}
- **Key Points**: {{key_points}}
- **Summary**: {{summary}}

## Methods

{{methods}}

## Findings

{{findings}}

## Clinical Relevance

{{clinical_relevance}}

## Quotes

{{quotes}}
`,
      "Topic_Hub.md": `---
type: topic
slug: "{{slug}}"
title: "{{title}}"
status: active
created: "{{date}}"
---

# Topic Hub: {{title}}

## Overview

{{description}}

## Research Questions

{{research_questions}}

## Sources

{{sources}}

## Reports

{{reports}}
`
    };
    return templates[templateName] || null;
  }
  async createTemplateFiles() {
    const templatesFolder = this.settings.templatesPath;
    await this.ensureFolderExists(templatesFolder);
    const templateFiles = [
      "DR_Seed.md",
      "DR_Plan.md",
      "DR_Report.md",
      "DR_SourceNote.md",
      "Topic_Hub.md"
    ];
    for (const templateFile of templateFiles) {
      const templatePath = (0, import_obsidian5.normalizePath)(`${templatesFolder}/${templateFile}`);
      const existingFile = this.app.vault.getAbstractFileByPath(templatePath);
      if (!existingFile) {
        const builtInTemplate = this.getBuiltInTemplate(templateFile);
        if (builtInTemplate) {
          await this.app.vault.create(templatePath, builtInTemplate);
        }
      }
    }
  }
  async ensureFolderExists(folderPath) {
    const normalizedPath = (0, import_obsidian5.normalizePath)(folderPath);
    const existingFolder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!existingFolder) {
      await this.app.vault.createFolder(normalizedPath);
    }
  }
  clearCache() {
    this.templateCache.clear();
  }
};

// src/services/LLMService.ts
var import_obsidian6 = require("obsidian");
var LLMService = class {
  constructor(settings) {
    this.adapters = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.initializeAdapters();
  }
  initializeAdapters() {
    this.adapters.set("ollama", new OllamaAdapter(this.settings));
    this.adapters.set("openai", new OpenAIAdapter(this.settings));
    this.adapters.set("anthropic", new AnthropicAdapter(this.settings));
    this.adapters.set("local", new LocalLLMAdapter(this.settings));
  }
  async generateText(prompt, options) {
    const adapter = this.adapters.get(this.settings.defaultLLMProvider);
    if (!adapter) {
      throw new Error(`LLM adapter '${this.settings.defaultLLMProvider}' not found`);
    }
    const isAvailable = await adapter.isAvailable();
    if (!isAvailable) {
      throw new Error(`LLM provider '${this.settings.defaultLLMProvider}' is not available. Please check your configuration.`);
    }
    return await adapter.generateText(prompt, options);
  }
  async generateSubQuestions(thesis, seedSummary, topic) {
    const prompt = `Based on the following research thesis and context, generate 6-9 specific sub-questions that would guide a comprehensive literature review. Organize them into these categories:

**Research Context:**
- Thesis: ${thesis}
- Topic: ${topic}
- Background: ${seedSummary}

Generate sub-questions covering these areas:

1. **Definitions & Distinctions** (1-2 questions)
2. **Causal Mechanisms** (1-2 questions)  
3. **Measurement & Assessment** (1-2 questions)
4. **Intervention Strategies** (1-2 questions)
5. **Individual Differences & Moderators** (1-2 questions)
6. **Contradictory Evidence & Limitations** (1 question)

Format your response as a simple numbered list:

1. [Definition question]
2. [Mechanism question]
3. [Assessment question]
4. [Intervention question]
5. [Individual differences question]
6. [Limitations question]
...

Each question should be:
- Specific and researchable
- Relevant to clinical/therapeutic practice
- Focused on empirical evidence
- Clear and actionable`;
    const response = await this.generateText(prompt, {
      temperature: 0.4,
      maxTokens: 600
    });
    return this.parseSubQuestions(response);
  }
  parseSubQuestions(response) {
    const lines = response.split("\n");
    const questions = [];
    for (const line of lines) {
      const trimmed = line.trim();
      const match = trimmed.match(/^\d+\.\s*(.+)$/);
      if (match) {
        questions.push(match[1].trim());
      }
    }
    while (questions.length < 6) {
      questions.push(`Additional research question needed for category ${questions.length + 1}`);
    }
    return questions.slice(0, 9);
  }
  updateSettings(settings) {
    this.settings = settings;
    this.initializeAdapters();
  }
  async testConnection(provider) {
    const providerToTest = provider || this.settings.defaultLLMProvider;
    const adapter = this.adapters.get(providerToTest);
    if (!adapter) {
      return { success: false, message: `Adapter '${providerToTest}' not found` };
    }
    try {
      const isAvailable = await adapter.isAvailable();
      if (!isAvailable) {
        return { success: false, message: `Provider '${providerToTest}' is not available` };
      }
      const testResponse = await adapter.generateText('Respond with just "OK" if you can understand this message.', {
        maxTokens: 10
      });
      if (testResponse.toLowerCase().includes("ok")) {
        return { success: true, message: `Connection to ${providerToTest} successful` };
      } else {
        return { success: false, message: `Unexpected response from ${providerToTest}` };
      }
    } catch (error) {
      return { success: false, message: `Connection failed: ${error.message}` };
    }
  }
};
var OllamaAdapter = class {
  constructor(settings) {
    this.name = "ollama";
    this.settings = settings;
  }
  async generateText(prompt, options) {
    const endpoint = this.settings.ollamaEndpoint || "http://localhost:11434";
    const requestData = {
      url: `${endpoint}/api/generate`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: (options == null ? void 0 : options.model) || "llama2",
        prompt,
        stream: false,
        options: {
          temperature: (options == null ? void 0 : options.temperature) || 0.7,
          num_predict: (options == null ? void 0 : options.maxTokens) || 800
        }
      })
    };
    const response = await (0, import_obsidian6.requestUrl)(requestData);
    const data = response.json;
    if (data.response) {
      return data.response;
    } else {
      throw new Error("Invalid response from Ollama");
    }
  }
  async isAvailable() {
    try {
      const endpoint = this.settings.ollamaEndpoint || "http://localhost:11434";
      const response = await (0, import_obsidian6.requestUrl)({
        url: `${endpoint}/api/version`,
        method: "GET"
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
};
var OpenAIAdapter = class {
  constructor(settings) {
    this.name = "openai";
    this.settings = settings;
  }
  async generateText(prompt, options) {
    if (!this.settings.openaiApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const requestData = {
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: (options == null ? void 0 : options.model) || "gpt-3.5-turbo",
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        max_tokens: (options == null ? void 0 : options.maxTokens) || 800
      })
    };
    const response = await (0, import_obsidian6.requestUrl)(requestData);
    const data = response.json;
    if (data.choices && data.choices[0] && data.choices[0].message) {
      return data.choices[0].message.content;
    } else {
      throw new Error("Invalid response from OpenAI");
    }
  }
  async isAvailable() {
    return !!this.settings.openaiApiKey;
  }
};
var AnthropicAdapter = class {
  constructor(settings) {
    this.name = "anthropic";
    this.settings = settings;
  }
  async generateText(prompt, options) {
    if (!this.settings.anthropicApiKey) {
      throw new Error("Anthropic API key not configured");
    }
    const requestData = {
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: (options == null ? void 0 : options.model) || "claude-3-sonnet-20240229",
        max_tokens: (options == null ? void 0 : options.maxTokens) || 800,
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        messages: [
          { role: "user", content: prompt }
        ]
      })
    };
    const response = await (0, import_obsidian6.requestUrl)(requestData);
    const data = response.json;
    if (data.content && data.content[0] && data.content[0].text) {
      return data.content[0].text;
    } else {
      throw new Error("Invalid response from Anthropic");
    }
  }
  async isAvailable() {
    return !!this.settings.anthropicApiKey;
  }
};
var LocalLLMAdapter = class {
  constructor(settings) {
    this.name = "local";
    this.settings = settings;
  }
  async generateText(prompt, options) {
    if (!this.settings.localEndpoint) {
      throw new Error("Local LLM endpoint not configured");
    }
    const requestData = {
      url: `${this.settings.localEndpoint}/v1/completions`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        prompt,
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        max_tokens: (options == null ? void 0 : options.maxTokens) || 800
      })
    };
    const response = await (0, import_obsidian6.requestUrl)(requestData);
    const data = response.json;
    if (data.choices && data.choices[0] && data.choices[0].text) {
      return data.choices[0].text;
    } else {
      throw new Error("Invalid response from local LLM");
    }
  }
  async isAvailable() {
    try {
      if (!this.settings.localEndpoint)
        return false;
      const response = await (0, import_obsidian6.requestUrl)({
        url: `${this.settings.localEndpoint}/v1/models`,
        method: "GET"
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
};

// src/services/GatekeeperService.ts
var GatekeeperService = class {
  constructor(llmService) {
    this.llmService = llmService;
  }
  async scoreSeed(seed) {
    const prompt = this.buildGatekeeperPrompt(seed);
    try {
      const response = await this.llmService.generateText(prompt, {
        temperature: 0.3,
        maxTokens: 500
      });
      return this.parseGatekeeperResponse(response);
    } catch (error) {
      console.error("Error in gatekeeper scoring:", error);
      throw new Error("Failed to score seed. Please check your LLM configuration.");
    }
  }
  buildGatekeeperPrompt(seed) {
    var _a;
    return `${GATEKEEPER_PROMPT}

**Research Seed to Evaluate:**

**Title:** ${seed.title}
**Topic:** ${seed.frontmatter.topic || "Unspecified"}
**Summary:** ${seed.summary}
**Initial Questions:**
${((_a = seed.questions) == null ? void 0 : _a.map((q) => `- ${q}`).join("\n")) || "No specific questions provided"}
**Priority Level:** ${seed.frontmatter.priority}

**Context:**
This seed is being evaluated for potential deep research in a therapeutic/clinical context. The researcher is particularly interested in evidence-based practices and theories that can be applied in therapy.

Please evaluate this seed based on the five criteria and provide your assessment in the following format:

**Scoring Breakdown:**
- Novelty (0-20): [score] - [brief explanation]
- Clinical Value (0-20): [score] - [brief explanation]  
- Research Readiness (0-20): [score] - [brief explanation]
- Synthesis Potential (0-20): [score] - [brief explanation]
- Personal Relevance (0-20): [score] - [brief explanation]

**Overall Assessment:**
Score: [total score out of 100]
Verdict: [deep-research/light-scan/archive]
Rationale: [2-3 sentences explaining your scoring decision]

**Research Directions:**
Top sub-topics to explore:
1. [specific area]
2. [specific area]  
3. [specific area]
4. [specific area]
5. [specific area]`;
  }
  parseGatekeeperResponse(response) {
    let assessment = {
      score: 0,
      verdict: "archive",
      rationale: "Unable to parse response",
      topSubTopics: [],
      novelty: 0,
      clinicalValue: 0,
      researchReadiness: 0,
      synthesisPotential: 0,
      personalRelevance: 0
    };
    try {
      const noveltyMatch = response.match(/Novelty \(0-20\):\s*(\d+)/i);
      if (noveltyMatch)
        assessment.novelty = parseInt(noveltyMatch[1]);
      const clinicalMatch = response.match(/Clinical Value \(0-20\):\s*(\d+)/i);
      if (clinicalMatch)
        assessment.clinicalValue = parseInt(clinicalMatch[1]);
      const readinessMatch = response.match(/Research Readiness \(0-20\):\s*(\d+)/i);
      if (readinessMatch)
        assessment.researchReadiness = parseInt(readinessMatch[1]);
      const synthesisMatch = response.match(/Synthesis Potential \(0-20\):\s*(\d+)/i);
      if (synthesisMatch)
        assessment.synthesisPotential = parseInt(synthesisMatch[1]);
      const relevanceMatch = response.match(/Personal Relevance \(0-20\):\s*(\d+)/i);
      if (relevanceMatch)
        assessment.personalRelevance = parseInt(relevanceMatch[1]);
      const scoreMatch = response.match(/Score:\s*(\d+)/i);
      if (scoreMatch) {
        assessment.score = parseInt(scoreMatch[1]);
      } else {
        assessment.score = assessment.novelty + assessment.clinicalValue + assessment.researchReadiness + assessment.synthesisPotential + assessment.personalRelevance;
      }
      const verdictMatch = response.match(/Verdict:\s*(deep-research|light-scan|archive)/i);
      if (verdictMatch) {
        assessment.verdict = verdictMatch[1].toLowerCase();
      } else {
        if (assessment.score >= 80) {
          assessment.verdict = "deep-research";
        } else if (assessment.score >= 50) {
          assessment.verdict = "light-scan";
        } else {
          assessment.verdict = "archive";
        }
      }
      const rationaleMatch = response.match(/Rationale:\s*([^\n]+(?:\n[^\n]+)*?)(?=\n\n|\n\*|$)/i);
      if (rationaleMatch) {
        assessment.rationale = rationaleMatch[1].trim();
      }
      const topicsSection = response.match(/Top sub-topics to explore:(.*?)(?=\n\n|$)/is);
      if (topicsSection) {
        const topicLines = topicsSection[1].split("\n").map((line) => line.trim()).filter((line) => line.match(/^\d+\.\s+/)).map((line) => line.replace(/^\d+\.\s+/, "")).slice(0, 5);
        assessment.topSubTopics = topicLines;
      }
      if (assessment.topSubTopics.length === 0) {
        assessment.topSubTopics = this.generateFallbackTopics(assessment);
      }
    } catch (error) {
      console.error("Error parsing gatekeeper response:", error);
      assessment.rationale = "Error parsing LLM response. Manual review recommended.";
    }
    assessment.score = Math.max(0, Math.min(100, assessment.score));
    assessment.novelty = Math.max(0, Math.min(20, assessment.novelty));
    assessment.clinicalValue = Math.max(0, Math.min(20, assessment.clinicalValue));
    assessment.researchReadiness = Math.max(0, Math.min(20, assessment.researchReadiness));
    assessment.synthesisPotential = Math.max(0, Math.min(20, assessment.synthesisPotential));
    assessment.personalRelevance = Math.max(0, Math.min(20, assessment.personalRelevance));
    return assessment;
  }
  generateFallbackTopics(assessment) {
    if (assessment.verdict === "deep-research") {
      return [
        "Theoretical foundations and definitions",
        "Empirical measurement approaches",
        "Intervention development and testing",
        "Individual differences and moderators",
        "Clinical applications and effectiveness"
      ];
    } else if (assessment.verdict === "light-scan") {
      return [
        "Current theoretical understanding",
        "Available assessment tools",
        "Preliminary intervention studies"
      ];
    } else {
      return [
        "Basic definitional clarity",
        "Initial empirical evidence"
      ];
    }
  }
  // Batch scoring for multiple seeds
  async scoreSeeds(seeds) {
    const results = /* @__PURE__ */ new Map();
    const concurrentLimit = 3;
    const batches = [];
    for (let i = 0; i < seeds.length; i += concurrentLimit) {
      batches.push(seeds.slice(i, i + concurrentLimit));
    }
    for (const batch of batches) {
      const promises = batch.map(async (seed) => {
        try {
          const assessment = await this.scoreSeed(seed);
          results.set(seed.id, assessment);
        } catch (error) {
          console.error(`Error scoring seed ${seed.id}:`, error);
          results.set(seed.id, {
            score: 0,
            verdict: "archive",
            rationale: "Scoring failed - manual review required",
            topSubTopics: [],
            novelty: 0,
            clinicalValue: 0,
            researchReadiness: 0,
            synthesisPotential: 0,
            personalRelevance: 0
          });
        }
      });
      await Promise.all(promises);
      if (batches.indexOf(batch) < batches.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    return results;
  }
  // Quality check for assessments
  validateAssessment(assessment) {
    const issues = [];
    const calculatedScore = assessment.novelty + assessment.clinicalValue + assessment.researchReadiness + assessment.synthesisPotential + assessment.personalRelevance;
    if (Math.abs(calculatedScore - assessment.score) > 5) {
      issues.push("Score inconsistent with breakdown components");
    }
    if (assessment.verdict === "deep-research" && assessment.score < 70) {
      issues.push('Verdict "deep-research" but score below typical threshold');
    } else if (assessment.verdict === "light-scan" && (assessment.score < 40 || assessment.score >= 80)) {
      issues.push('Verdict "light-scan" but score outside typical range');
    } else if (assessment.verdict === "archive" && assessment.score > 60) {
      issues.push('Verdict "archive" but score above typical threshold');
    }
    if (!assessment.rationale || assessment.rationale.length < 20) {
      issues.push("Rationale too brief or missing");
    }
    if (assessment.topSubTopics.length === 0) {
      issues.push("No sub-topics identified");
    }
    return {
      isValid: issues.length === 0,
      issues
    };
  }
  // Analytics and insights
  getAssessmentStats(assessments) {
    if (assessments.length === 0) {
      return {
        averageScore: 0,
        verdictDistribution: {},
        topCriteria: [],
        commonTopics: []
      };
    }
    const averageScore = assessments.reduce((sum, a) => sum + a.score, 0) / assessments.length;
    const verdictCounts = assessments.reduce((counts, a) => {
      counts[a.verdict] = (counts[a.verdict] || 0) + 1;
      return counts;
    }, {});
    const criteriaScores = {
      novelty: assessments.reduce((sum, a) => sum + a.novelty, 0) / assessments.length,
      clinicalValue: assessments.reduce((sum, a) => sum + a.clinicalValue, 0) / assessments.length,
      researchReadiness: assessments.reduce((sum, a) => sum + a.researchReadiness, 0) / assessments.length,
      synthesisPotential: assessments.reduce((sum, a) => sum + a.synthesisPotential, 0) / assessments.length,
      personalRelevance: assessments.reduce((sum, a) => sum + a.personalRelevance, 0) / assessments.length
    };
    const topCriteria = Object.entries(criteriaScores).sort(([, a], [, b]) => b - a).map(([criterion]) => criterion);
    const allTopics = assessments.flatMap((a) => a.topSubTopics);
    const topicCounts = allTopics.reduce((counts, topic) => {
      counts[topic] = (counts[topic] || 0) + 1;
      return counts;
    }, {});
    const commonTopics = Object.entries(topicCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([topic]) => topic);
    return {
      averageScore,
      verdictDistribution: verdictCounts,
      topCriteria,
      commonTopics
    };
  }
};

// src/ui/ResearchConsole.ts
var import_obsidian7 = require("obsidian");
var RESEARCH_CONSOLE_VIEW_TYPE = "deep-research-console";
var ResearchConsoleView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.state = {
      activeTab: "seeds",
      filters: {},
      selectedItems: []
    };
  }
  getViewType() {
    return RESEARCH_CONSOLE_VIEW_TYPE;
  }
  getDisplayText() {
    return "Research Console";
  }
  getIcon() {
    return "search";
  }
  async onOpen() {
    await this.render();
  }
  async onClose() {
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("deep-research-console");
    const header = container.createDiv("console-header");
    const title = header.createEl("h2", { text: "Research Console" });
    const refreshBtn = header.createEl("button", {
      cls: "mod-cta",
      text: "Refresh"
    });
    refreshBtn.addEventListener("click", () => this.refresh());
    const tabNav = container.createDiv("tab-nav");
    const tabs = [
      { id: "seeds", label: "Seeds", icon: "lightbulb" },
      { id: "plans", label: "Plans", icon: "clipboard-list" },
      { id: "runs", label: "Runs", icon: "play" },
      { id: "sources", label: "Sources", icon: "book-open" },
      { id: "claims", label: "Claims", icon: "check-circle" }
    ];
    tabs.forEach((tab) => {
      const tabEl = tabNav.createDiv(`tab ${this.state.activeTab === tab.id ? "active" : ""}`);
      tabEl.innerHTML = `
				<span class="tab-icon" data-icon="${tab.icon}"></span>
				<span class="tab-label">${tab.label}</span>
			`;
      tabEl.addEventListener("click", () => this.switchTab(tab.id));
    });
    const filtersDiv = container.createDiv("filters");
    await this.renderFilters(filtersDiv);
    const contentDiv = container.createDiv("tab-content");
    await this.renderTabContent(contentDiv);
    const actionsDiv = container.createDiv("actions-bar");
    await this.renderActions(actionsDiv);
  }
  async renderFilters(container) {
    container.innerHTML = `
			<div class="filter-group">
				<label for="topic-filter">Topic:</label>
				<select id="topic-filter">
					<option value="">All Topics</option>
				</select>
			</div>
			<div class="filter-group">
				<label for="status-filter">Status:</label>
				<select id="status-filter">
					<option value="">All Statuses</option>
				</select>
			</div>
			<div class="filter-group">
				<label for="score-filter">Min Score:</label>
				<input type="number" id="score-filter" min="0" max="100" placeholder="0">
			</div>
		`;
    await this.populateFilterOptions();
    container.querySelectorAll("select, input").forEach((el) => {
      el.addEventListener("change", () => this.updateFilters());
    });
  }
  async populateFilterOptions() {
    const topics = await this.plugin.dataManager.getTopics();
    const topicSelect = this.containerEl.querySelector("#topic-filter");
    topics.forEach((topic) => {
      const option = topicSelect.createEl("option", {
        value: topic.id,
        text: topic.title
      });
    });
    const statusSelect = this.containerEl.querySelector("#status-filter");
    const statusOptions = this.getStatusOptionsForTab(this.state.activeTab);
    statusOptions.forEach((status) => {
      statusSelect.createEl("option", {
        value: status,
        text: status.charAt(0).toUpperCase() + status.slice(1)
      });
    });
  }
  getStatusOptionsForTab(tab) {
    switch (tab) {
      case "seeds":
        return ["captured", "scored", "promoted", "archived"];
      case "plans":
        return ["planned", "running", "completed", "failed"];
      case "runs":
        return ["queued", "running", "completed", "failed"];
      default:
        return [];
    }
  }
  async renderTabContent(container) {
    container.empty();
    switch (this.state.activeTab) {
      case "seeds":
        await this.renderSeedsTab(container);
        break;
      case "plans":
        await this.renderPlansTab(container);
        break;
      case "runs":
        await this.renderRunsTab(container);
        break;
      case "sources":
        await this.renderSourcesTab(container);
        break;
      case "claims":
        await this.renderClaimsTab(container);
        break;
    }
  }
  async renderSeedsTab(container) {
    var _a;
    const seeds = await this.plugin.dataManager.getSeeds(this.state.filters);
    if (seeds.length === 0) {
      container.innerHTML = `
				<div class="empty-state">
					<p>No seeds found matching your filters.</p>
					<button class="mod-cta" id="create-seed">Create New Seed</button>
				</div>
			`;
      (_a = container.querySelector("#create-seed")) == null ? void 0 : _a.addEventListener("click", () => {
        this.plugin.commandManager.createSeed();
      });
      return;
    }
    const table = container.createDiv("data-table");
    table.innerHTML = `
			<table>
				<thead>
					<tr>
						<th><input type="checkbox" id="select-all"></th>
						<th>Title</th>
						<th>Topic</th>
						<th>Score</th>
						<th>Status</th>
						<th>Created</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${seeds.map((seed) => `
						<tr data-id="${seed.id}">
							<td><input type="checkbox" class="item-select" value="${seed.id}"></td>
							<td><a href="${seed.filePath}">${seed.title}</a></td>
							<td>${seed.frontmatter.topic || "-"}</td>
							<td>${seed.frontmatter.score || 0}</td>
							<td><span class="status-badge ${seed.frontmatter.status}">${seed.frontmatter.status}</span></td>
							<td>${seed.frontmatter.created || "-"}</td>
							<td>
								<button class="score-btn" data-id="${seed.id}">Score</button>
								<button class="promote-btn" data-id="${seed.id}">Promote</button>
							</td>
						</tr>
					`).join("")}
				</tbody>
			</table>
		`;
    this.addTableEventListeners(table);
  }
  async renderPlansTab(container) {
    const plans = await this.plugin.dataManager.getPlans(this.state.filters);
    if (plans.length === 0) {
      container.innerHTML = '<div class="empty-state"><p>No plans found.</p></div>';
      return;
    }
    const table = container.createDiv("data-table");
    table.innerHTML = `
			<table>
				<thead>
					<tr>
						<th><input type="checkbox" id="select-all"></th>
						<th>Title</th>
						<th>Topic</th>
						<th>Status</th>
						<th>Deliverables</th>
						<th>Created</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${plans.map((plan) => `
						<tr data-id="${plan.id}">
							<td><input type="checkbox" class="item-select" value="${plan.id}"></td>
							<td><a href="${plan.filePath}">${plan.title}</a></td>
							<td>${plan.frontmatter.topic}</td>
							<td><span class="status-badge ${plan.frontmatter.status}">${plan.frontmatter.status}</span></td>
							<td>${plan.frontmatter.deliverables.join(", ")}</td>
							<td>${plan.frontmatter.created || "-"}</td>
							<td>
								<button class="run-btn" data-id="${plan.id}">Run</button>
								<button class="edit-btn" data-id="${plan.id}">Edit</button>
							</td>
						</tr>
					`).join("")}
				</tbody>
			</table>
		`;
    this.addTableEventListeners(table);
  }
  async renderRunsTab(container) {
    const jobs = await this.plugin.jobManager.getJobs();
    if (jobs.length === 0) {
      container.innerHTML = '<div class="empty-state"><p>No research runs found.</p></div>';
      return;
    }
    const table = container.createDiv("data-table");
    table.innerHTML = `
			<table>
				<thead>
					<tr>
						<th>Run ID</th>
						<th>Plan</th>
						<th>Status</th>
						<th>Progress</th>
						<th>Started</th>
						<th>Duration</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${jobs.map((job) => {
      var _a;
      return `
						<tr data-id="${job.id}">
							<td><code>${job.id}</code></td>
							<td>${job.planId}</td>
							<td><span class="status-badge ${job.status}">${job.status}</span></td>
							<td>
								<div class="progress-bar">
									<div class="progress-fill" style="width: ${job.progress || 0}%"></div>
								</div>
								<span class="progress-text">${job.progress || 0}%</span>
							</td>
							<td>${((_a = job.startTime) == null ? void 0 : _a.toLocaleDateString()) || "-"}</td>
							<td>${this.formatDuration(job.startTime, job.endTime)}</td>
							<td>
								<button class="view-btn" data-id="${job.id}">View</button>
								${job.status === "running" ? `<button class="cancel-btn" data-id="${job.id}">Cancel</button>` : ""}
							</td>
						</tr>
					`;
    }).join("")}
				</tbody>
			</table>
		`;
    this.addTableEventListeners(table);
  }
  async renderSourcesTab(container) {
    const sources = await this.plugin.dataManager.getSources(this.state.filters);
    if (sources.length === 0) {
      container.innerHTML = '<div class="empty-state"><p>No sources found.</p></div>';
      return;
    }
    const table = container.createDiv("data-table");
    table.innerHTML = `
			<table>
				<thead>
					<tr>
						<th><input type="checkbox" id="select-all"></th>
						<th>Title</th>
						<th>Authors</th>
						<th>Year</th>
						<th>Quality</th>
						<th>Claims</th>
						<th>Added</th>
					</tr>
				</thead>
				<tbody>
					${sources.map((source) => {
      var _a, _b;
      return `
						<tr data-id="${source.id}">
							<td><input type="checkbox" class="item-select" value="${source.id}"></td>
							<td><a href="${source.filePath}">${source.title}</a></td>
							<td>${((_a = source.frontmatter.authors) == null ? void 0 : _a.join(", ")) || "-"}</td>
							<td>${source.frontmatter.year || "-"}</td>
							<td><span class="quality-badge ${source.frontmatter.quality}">${source.frontmatter.quality}</span></td>
							<td>${((_b = source.frontmatter.supports_claims) == null ? void 0 : _b.length) || 0}</td>
							<td>${source.frontmatter.created || "-"}</td>
						</tr>
					`;
    }).join("")}
				</tbody>
			</table>
		`;
    this.addTableEventListeners(table);
  }
  async renderClaimsTab(container) {
    const reports = await this.plugin.dataManager.getReports(this.state.filters);
    const claims = reports.flatMap((report) => report.claims || []);
    if (claims.length === 0) {
      container.innerHTML = '<div class="empty-state"><p>No claims found.</p></div>';
      return;
    }
    const table = container.createDiv("data-table");
    table.innerHTML = `
			<table>
				<thead>
					<tr>
						<th>Claim</th>
						<th>Confidence</th>
						<th>Sources</th>
						<th>Contradictions</th>
					</tr>
				</thead>
				<tbody>
					${claims.map((claim) => `
						<tr data-id="${claim.id}">
							<td>${claim.text}</td>
							<td><span class="confidence-badge ${claim.confidence}">${claim.confidence}</span></td>
							<td>${claim.sourceIds.length}</td>
							<td>${claim.contradictions ? "\u26A0\uFE0F" : "\u2705"}</td>
						</tr>
					`).join("")}
				</tbody>
			</table>
		`;
  }
  async renderActions(container) {
    var _a;
    const selectedCount = this.state.selectedItems.length;
    container.innerHTML = `
			<div class="selection-info">
				<span>${selectedCount} item(s) selected</span>
			</div>
			<div class="bulk-actions">
				<button class="batch-btn" ${selectedCount === 0 ? "disabled" : ""}>Batch Process</button>
				<button class="delete-btn" ${selectedCount === 0 ? "disabled" : ""}>Delete</button>
			</div>
			<div class="create-actions">
				<button class="mod-cta" id="create-new">Create New</button>
			</div>
		`;
    (_a = container.querySelector("#create-new")) == null ? void 0 : _a.addEventListener("click", () => {
      this.showCreateMenu();
    });
  }
  addTableEventListeners(table) {
    const selectAllCheckbox = table.querySelector("#select-all");
    selectAllCheckbox == null ? void 0 : selectAllCheckbox.addEventListener("change", (e) => {
      const isChecked = e.target.checked;
      const itemCheckboxes = table.querySelectorAll(".item-select");
      itemCheckboxes.forEach((checkbox) => {
        checkbox.checked = isChecked;
      });
      this.updateSelection();
    });
    table.querySelectorAll(".item-select").forEach((checkbox) => {
      checkbox.addEventListener("change", () => this.updateSelection());
    });
    table.querySelectorAll(".score-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const seedId = e.target.dataset.id;
        this.plugin.commandManager.scoreSeed(seedId);
      });
    });
    table.querySelectorAll(".promote-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const seedId = e.target.dataset.id;
        this.plugin.commandManager.promoteSeedToPlan(seedId);
      });
    });
    table.querySelectorAll(".run-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const planId = e.target.dataset.id;
        this.plugin.commandManager.runPlan(planId);
      });
    });
  }
  updateSelection() {
    const checkboxes = this.containerEl.querySelectorAll(".item-select:checked");
    this.state.selectedItems = Array.from(checkboxes).map((cb) => cb.value);
    const actionsDiv = this.containerEl.querySelector(".actions-bar");
    if (actionsDiv) {
      this.renderActions(actionsDiv);
    }
  }
  updateFilters() {
    var _a, _b, _c;
    const topicFilter = (_a = this.containerEl.querySelector("#topic-filter")) == null ? void 0 : _a.value;
    const statusFilter = (_b = this.containerEl.querySelector("#status-filter")) == null ? void 0 : _b.value;
    const scoreFilter = (_c = this.containerEl.querySelector("#score-filter")) == null ? void 0 : _c.value;
    this.state.filters = {
      topic: topicFilter || void 0,
      status: statusFilter || void 0,
      score: scoreFilter ? parseInt(scoreFilter) : void 0
    };
    const contentDiv = this.containerEl.querySelector(".tab-content");
    if (contentDiv) {
      this.renderTabContent(contentDiv);
    }
  }
  switchTab(tabId) {
    this.state.activeTab = tabId;
    this.state.selectedItems = [];
    this.render();
  }
  showCreateMenu() {
    const menu = new import_obsidian7.Menu();
    menu.addItem((item) => {
      item.setTitle("New Seed").setIcon("lightbulb").onClick(() => this.plugin.commandManager.createSeed());
    });
    menu.addItem((item) => {
      item.setTitle("New Topic Hub").setIcon("folder").onClick(() => this.plugin.commandManager.createTopicHub());
    });
    menu.showAtMouseEvent(event);
  }
  formatDuration(start, end) {
    if (!start)
      return "-";
    const endTime = end || new Date();
    const durationMs = endTime.getTime() - start.getTime();
    const minutes = Math.floor(durationMs / 6e4);
    const seconds = Math.floor(durationMs % 6e4 / 1e3);
    if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    }
    return `${seconds}s`;
  }
  async refresh() {
    await this.plugin.dataManager.refreshCache();
    await this.render();
  }
};

// main.ts
var DeepResearchPlugin = class extends import_obsidian8.Plugin {
  // Will be implemented later
  async onload() {
    await this.loadSettings();
    this.llmService = new LLMService(this.settings);
    this.gatekeeperService = new GatekeeperService(this.llmService);
    this.dataManager = new DataManager(this.app, this.settings);
    this.templateManager = new TemplateManager(this.app, this.settings);
    this.commandManager = new CommandManager(this.app, this);
    this.jobManager = {
      getJobs: async () => []
    };
    this.registerView(
      RESEARCH_CONSOLE_VIEW_TYPE,
      (leaf) => new ResearchConsoleView(leaf, this)
    );
    this.commandManager.registerCommands();
    this.addRibbonIcon("search", "Open Research Console", () => {
      this.activateView();
    });
    this.addSettingTab(new DeepResearchSettingTab(this.app, this));
    if (this.isFirstRun()) {
      await this.initializePlugin();
    }
    console.log("Deep Research Assistant plugin loaded");
  }
  onunload() {
    console.log("Deep Research Assistant plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.llmService) {
      this.llmService.updateSettings(this.settings);
    }
  }
  isFirstRun() {
    return !this.settings.templatesPath || this.settings.templatesPath === DEFAULT_SETTINGS.templatesPath;
  }
  async initializePlugin() {
    try {
      await this.templateManager.createTemplateFiles();
      await this.createFolderStructure();
      new import_obsidian8.Notice("Deep Research Assistant initialized! Template files and folder structure created.");
    } catch (error) {
      console.error("Error initializing plugin:", error);
      new import_obsidian8.Notice("Error initializing Deep Research Assistant. Check console for details.");
    }
  }
  async createFolderStructure() {
    const folders = [
      this.settings.seedsPath,
      this.settings.plansPath,
      this.settings.reportsPath,
      this.settings.sourcesPath,
      this.settings.topicsPath,
      this.settings.templatesPath
    ];
    for (const folderPath of folders) {
      try {
        const existingFolder = this.app.vault.getAbstractFileByPath(folderPath);
        if (!existingFolder) {
          await this.app.vault.createFolder(folderPath);
        }
      } catch (error) {
        console.warn(`Could not create folder ${folderPath}:`, error);
      }
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(RESEARCH_CONSOLE_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({
        type: RESEARCH_CONSOLE_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
};
var DeepResearchSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Deep Research Assistant Settings" });
    containerEl.createEl("h3", { text: "Folder Paths" });
    new import_obsidian8.Setting(containerEl).setName("Seeds Path").setDesc("Where to store research seeds").addText((text) => text.setPlaceholder("01_Inbox/Seeds").setValue(this.plugin.settings.seedsPath).onChange(async (value) => {
      this.plugin.settings.seedsPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Plans Path").setDesc("Where to store research plans").addText((text) => text.setPlaceholder("02_Research/Plans").setValue(this.plugin.settings.plansPath).onChange(async (value) => {
      this.plugin.settings.plansPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Reports Path").setDesc("Where to store research reports").addText((text) => text.setPlaceholder("02_Research/Reports").setValue(this.plugin.settings.reportsPath).onChange(async (value) => {
      this.plugin.settings.reportsPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Sources Path").setDesc("Where to store source notes").addText((text) => text.setPlaceholder("02_Research/Sources").setValue(this.plugin.settings.sourcesPath).onChange(async (value) => {
      this.plugin.settings.sourcesPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Topics Path").setDesc("Where to store topic hubs").addText((text) => text.setPlaceholder("02_Research/Topics").setValue(this.plugin.settings.topicsPath).onChange(async (value) => {
      this.plugin.settings.topicsPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Templates Path").setDesc("Where to store note templates").addText((text) => text.setPlaceholder("00_System/Templates").setValue(this.plugin.settings.templatesPath).onChange(async (value) => {
      this.plugin.settings.templatesPath = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "LLM Provider" });
    new import_obsidian8.Setting(containerEl).setName("Default LLM Provider").setDesc("Choose your preferred language model provider").addDropdown((dropdown) => {
      dropdown.addOptions({
        "ollama": "Ollama (Local)",
        "openai": "OpenAI",
        "anthropic": "Anthropic",
        "local": "Local/Custom Endpoint"
      });
      dropdown.setValue(this.plugin.settings.defaultLLMProvider).onChange(async (value) => {
        this.plugin.settings.defaultLLMProvider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.defaultLLMProvider === "ollama") {
      new import_obsidian8.Setting(containerEl).setName("Ollama Endpoint").setDesc("URL for your Ollama instance").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaEndpoint || "").onChange(async (value) => {
        this.plugin.settings.ollamaEndpoint = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLLMProvider === "openai") {
      new import_obsidian8.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key").addText((text) => {
        text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey || "").onChange(async (value) => {
          this.plugin.settings.openaiApiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.type = "password";
      });
    }
    if (this.plugin.settings.defaultLLMProvider === "anthropic") {
      new import_obsidian8.Setting(containerEl).setName("Anthropic API Key").setDesc("Your Anthropic API key").addText((text) => {
        text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey || "").onChange(async (value) => {
          this.plugin.settings.anthropicApiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.type = "password";
      });
    }
    if (this.plugin.settings.defaultLLMProvider === "local") {
      new import_obsidian8.Setting(containerEl).setName("Local Endpoint").setDesc("URL for your local LLM server").addText((text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.localEndpoint || "").onChange(async (value) => {
        this.plugin.settings.localEndpoint = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian8.Setting(containerEl).setName("Test LLM Connection").setDesc("Verify that your LLM provider is working").addButton((button) => {
      button.setButtonText("Test Connection").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.llmService.testConnection();
          if (result.success) {
            new import_obsidian8.Notice("\u2705 " + result.message);
          } else {
            new import_obsidian8.Notice("\u274C " + result.message);
          }
        } catch (error) {
          new import_obsidian8.Notice("\u274C Connection test failed: " + error.message);
        }
        button.setButtonText("Test Connection");
        button.setDisabled(false);
      });
    });
    containerEl.createEl("h3", { text: "Gatekeeper Settings" });
    new import_obsidian8.Setting(containerEl).setName("Scoring Threshold").setDesc("Minimum score for deep research recommendation").addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.gatekeeperThreshold).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.gatekeeperThreshold = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Auto-promote High Scores").setDesc("Automatically offer to create plans for seeds that score above threshold").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoPromoteHighScore).onChange(async (value) => {
      this.plugin.settings.autoPromoteHighScore = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Omnivore Integration" });
    new import_obsidian8.Setting(containerEl).setName("Enable Omnivore").setDesc("Connect to Omnivore for importing highlights").addToggle((toggle) => toggle.setValue(this.plugin.settings.omnivoreEnabled).onChange(async (value) => {
      this.plugin.settings.omnivoreEnabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.omnivoreEnabled) {
      new import_obsidian8.Setting(containerEl).setName("Omnivore API Key").setDesc("Your Omnivore API key").addText((text) => {
        text.setPlaceholder("Your API key...").setValue(this.plugin.settings.omnivoreApiKey || "").onChange(async (value) => {
          this.plugin.settings.omnivoreApiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.type = "password";
      });
      new import_obsidian8.Setting(containerEl).setName("Auto-sync Highlights").setDesc("Automatically sync highlights from Omnivore").addToggle((toggle) => toggle.setValue(this.plugin.settings.omnivoreAutoSync).onChange(async (value) => {
        this.plugin.settings.omnivoreAutoSync = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Advanced" });
    new import_obsidian8.Setting(containerEl).setName("Reset Plugin").setDesc("Reset all settings and recreate template files").addButton((button) => {
      button.setButtonText("Reset Plugin").setWarning().onClick(async () => {
        const confirmed = confirm(
          "This will reset all plugin settings and recreate template files. Are you sure?"
        );
        if (confirmed) {
          this.plugin.settings = { ...DEFAULT_SETTINGS };
          await this.plugin.saveSettings();
          await this.plugin.templateManager.createTemplateFiles();
          new import_obsidian8.Notice("Plugin reset successfully. Please reload Obsidian.");
        }
      });
    });
  }
};
